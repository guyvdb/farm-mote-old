#pragma once

#include <stddef.h>
#include <stdint.h>


// A frame can be extracted from a set of bytes. A frame can also be turned into a set of bytes.
// Frames contain commands. Frames are sent from client to server or vise versa.
// Data in the frame is in big endian or network byte order.
//
// A frame has a payload. A frame also has a payload len. This len is uint8_t meaning that the
// maximum size of the payload is 255 bytes.

#define FRAME_STACK_BUF_LEN 256 // the size of on stack buffers used within the frame library
                                // see framebuf_deframe() & frame_encode()

#define FRAME_PROTOCOL_VERSION 0x1

#define ESCAPE 0x1B      // 27
#define SFLAG 0x2        // 2
#define EFLAG 0x3        // 3


struct frame; // forward declare 


// Structure of the frame bytes 
//
// |--------------|---------------|------------|---------------|-------------------|---------------|------------|-----------|--------------------|--------------|
// | SFLAG 1 byte | version 1byte | id 2 bytes | tcount 1 byte | timestamp 4 bytes | refid 2 bytes | cmd 1 byte | len 1byte | payload <varbytes> | EFLAG 1 byte |
// |--------------|---------------|------------|---------------|-------------------|---------------|------------|-----------|--------------------|--------------|
//
// The SFLAG and EFLAG demarkate the start and end of the frame. 
// The frame is 12 bytes + payload size
// The transmitted bytes are 14 bytes + payload size + any escape characters such as SFLAG, EFLAG and ESCAPE, as needed.
// The meaning of payload is individually defined by each command
struct frame {
  // the prev and next pointers are not part of the wire protocol
  struct frame *prev;
  struct frame *next;
  

  
   // The version of the frame protocol.
  uint8_t version;
  
  // The id of this frame generated by the client or the server. Client and server ids have no
  // shared sequence association between them. Id increments but is not monotonic. It wrapps and
  // repeats the sequence when limit is reached. The id should never be set to 0x0. It should be
  // set in the range 1 to max size. The counter can be reset at any time, such as on reboot.
  uint16_t id;

  // transmission count -- how many times has this frame been sent 
  uint8_t tcount;

  // This is a time stamp of when this frame was transmitted. It is seconds only. It is tv_sec
  // of struct timeval. The value is signed 32 bit integer big endian encoded.
  int32_t timestamp;

  // This is the reference frame id. A frame that this frame is in response to. This could be
  // set to 0x0 if this frame does not reference another frame.
  uint16_t refid;

  // This is the command identifier of this frame
  uint8_t cmd;

  // This is the length of the payload of this frame. The maximum is 255 bytes
  uint8_t len;

  // This is the payload of this frame.
  uint8_t *payload;

  // argument pointer used to insert/extract payloads
  uint8_t argptr;
};
typedef struct frame frame_t;


// get the next frame id.  sequence is reset to 1 at reboot.
// return - an auto incrementing integer sequence.
uint16_t frame_next_id(void);

// Create a frame. Memory is allocated for the frame and len bytes is allocated for the payload
// cmd - the command to set on the frame
// ref - the refid of another frame
// timestamp - the timestamp to place on the frame 
// len - the length of the payload buffer allocated inside the frame
// return - a pointer to a new frame or null on error.
frame_t *frame_create(uint8_t cmd, uint8_t ref, int32_t timestamp, size_t len);

// Create a frame from a set of bytes that have been pulled off the wire.  Memory is allocated
// for the frame_t struct and the frames internal payload. A call to frame_free() needs to
// be performed by the caller to free the memory. The data being passed in is unescaped with
// no control characters present.
// data - the bytes that have been pulled of the wire
// len - the length of the data
// return - a new frame pointer or null if an error occured
frame_t *frame_decode(uint8_t *data, size_t len);

// Given a frame, encode it into a series of bytes that can be sent across the network
// frame  - the frame to encode.
// data - the buffer to place the encoded bytes into.
// len    - the size of the buffer.
// return - no bytes encoded  on success or 0 on failure 
int frame_encode(frame_t *frame, uint8_t *data, size_t len);

// Given a frame, calculate the number of bytes that this frame will encode to.
// frame - the frame to do the calculation on.
// return - the number of bytes needed to encode this frame.
int frame_encoded_len(frame_t *frame);

// Free a frame. Free the frame struct memory and the memory that was allocated for *payload.
// frame - the frame that should be freed
void frame_free(frame_t *frame);

// Given a frame, turn it into a char* that can be printed for debugging purposes.
// Memory is allocated for the result and the caller must free it.
// frame - the frame to create a string representation from
// return - a newly allocated null terminated string or null on error.
char *frame_to_string(frame_t *frame);

// Start to access frame args. This sets an interal pointer to the beginning of
// the payload buffer where arguments can be inserted or extracted. Inserting
// an argument overwites memory, extracting increments the pointer.
// frame - the frame to start processing
void frame_args_begin(frame_t *frame);

// Finish accessing frame args. This does the same as frame_args_begin, resetting
// the internal pointer
// frame - the frame that we have finished processing
void frame_args_end(frame_t *frame);

// Get a uint8 from the frame payload. This advances the internal pointer.
// frame - the frame to get the argument from
// result - a pointer to write the result to
// return - 1 on success or 0 on failure
int frame_args_get_uint8(frame_t *frame, uint8_t *result);

// Get a uint16 from the frame payload. This advances the internal pointer.
// frame - the frame to get the argument from
// result - a pointer to write the result to
// return - 1 on success or 0 on failure
int frame_args_get_uint16(frame_t *frame, uint16_t *result);

// Get a uint32 from the frame payload. This advances the internal pointer.
// frame - the frame to get the argument from
// result - a pointer to write the result to
// return - 1 on success or 0 on failure
int frame_args_get_uint32(frame_t *frame, uint32_t *result);

// Get the length of the next string argument in the payload. This advances
// the internal pointer. The argument is length encoded. I.e.
// len(uint8)<len bytes>... This function returns the len portion,
// including space to null terminate the char string.
int frame_args_get_string_len(frame_t *frame, size_t *result);

// Get a null terminated string argument from the payload. This advances
// the internal pointer. The result buffer needs to be at least len bytes
// long. Len needs to be provided from a previous call to
// frame_arg_get_string_len().
// frame - the frame to get the argument from
// result - a char buffer len bytes long
// len - the number of char bytes that will be extracted including the 0x0 termination 
// return - 1 on success or 0 on failure
int frame_args_get_string(frame_t *frame, char *result, size_t len);


// Put a uint8 into the frame payload at the point of the internal pointer
// If the pointer is in the wrong place data is overwitten. This will
// fail if there is not enough space in the frames payload buffer
// frame - the frame to put the argument into
// value - the value to be written
// return - 1 on success or 0 on failure
int frame_args_put_uint8(frame_t *frame, uint8_t value);


// Put a uint16 into the frame payload at the point of the internal pointer
// If the pointer is in the wrong place data is overwitten. This will
// fail if there is not enough space in the frames payload buffer
// frame - the frame to put the argument into
// value - the value to be written
// return - 1 on success or 0 on failure
int frame_args_put_uint16(frame_t *frame, uint16_t value);

// Put a uint32 into the frame payload at the point of the internal pointer
// If the pointer is in the wrong place data is overwitten. This will
// fail if there is not enough space in the frames payload buffer
// frame - the frame to put the argument into
// value - the value to be written
// return - 1 on success or 0 on failure
int frame_args_put_uint32(frame_t *frame, uint32_t value);


// Put a string into the frame payload at the point of the internal pointer
// If the pointer is in the wrong place data is overwitten. This will
// fail if there is not enough space in the frames payload buffer
// frame - the frame to put the argument into
// value - the value to be written - must be a null terminated string.
// return - 1 on success or 0 on failure
int frame_args_put_string(frame_t *frame, const char* value);





